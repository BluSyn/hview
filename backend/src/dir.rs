use std::fs::read_dir;
use std::path::PathBuf;
use thiserror::Error;

use chrono::{TimeZone, Utc};
use rand::seq::IteratorRandom;
use serde::{Deserialize, Serialize};

use crate::config::{BASEPATH, CFG, DIR, THUMB_FORMAT};

#[derive(Error, Debug)]
pub enum DirError {
    #[error("Directory not found")]
    NotFound,

    #[error(transparent)]
    IOError(#[from] std::io::Error),
}

#[derive(Serialize, Deserialize, Debug)]
pub struct FileEntry {
    name: String,
    path: PathBuf,
    size: u64,
    date: u64,
    date_string: String,
    thumb: Option<PathBuf>,
    ext: Option<String>,
}

impl FileEntry {
    // Generate FileEntry struct from DirEntry obbject
    // DirEntry generated by std::fs::read_dir
    fn from_entry(entry: std::fs::DirEntry) -> Result<Self, DirError> {
        let meta = entry.metadata()?;
        let name = entry.file_name().into_string().unwrap();
        let path = if let Ok(path) = entry.path().strip_prefix(&*DIR) {
            path.to_path_buf()
        } else {
            entry.path()
        };
        let size = meta.len();
        let date = if let Ok(date) = meta.modified() {
            date.duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs()
        } else {
            0
        };
        let date_string = if date > 0 {
            Utc.timestamp(date as i64, 0).format("%Y-%m-%d").to_string()
        } else {
            String::from("")
        };

        let ext = if let Some(ext) = path.extension() {
            Some(ext.to_str().unwrap().to_string())
        } else {
            None
        };

        let thumb = if meta.is_dir() {
            Self::get_dir_thumb(&entry.path())
        } else {
            Self::get_file_thumb(&entry.path())
        };

        Ok(Self {
            name,
            path,
            size,
            date,
            date_string,
            thumb,
            ext,
        })
    }

    fn get_dir_thumb(path: &PathBuf) -> Option<PathBuf> {
        if let Some(th) = Self::get_random_thumb(&path.join(".th")) {
            Some(th.strip_prefix(&*DIR).ok()?.to_path_buf())
        } else if let Some(th) = Self::get_sub_dir_thumb(&path) {
            Some(th.strip_prefix(&*DIR).ok()?.to_path_buf())
        } else {
            None
        }
    }

    fn get_file_thumb(path: &PathBuf) -> Option<PathBuf> {
        if let Ok(tpath) = Self::file_path_to_thumb(&path) {
            if tpath.exists() {
                Some(tpath.strip_prefix(&*DIR).ok()?.to_path_buf())
            } else {
                None
            }
        } else {
            None
        }
    }

    // Check 2-levels deep for thumbnail of folder, return first dir found
    // TODO: This could be more efficient.
    fn get_sub_dir_thumb(path: &PathBuf) -> Option<PathBuf> {
        for subentry in read_dir(&path).ok()? {
            if let Ok(subentry) = subentry {
                let subpath = subentry.path();
                if let Some(th) = FileEntry::get_random_thumb(&subpath.join(".th")) {
                    return Some(th);
                }
            }
        }

        None
    }

    // Convert /dir/file.jpg -> /dir/.th/file.jpg.avif
    pub fn file_path_to_thumb(file: &PathBuf) -> Result<PathBuf, &'static str> {
        let thumb_name = format!(
            ".th/{}.{}",
            file.file_name()
                .ok_or("Filename")?
                .to_str()
                .ok_or("Filename String")?,
            *THUMB_FORMAT
        );
        let file_thumb = file.parent().ok_or("Parent directory")?.join(&thumb_name);

        Ok(file_thumb)
    }

    // Get file inside dir that ends with THUMB_FORMAT, if exists
    pub fn get_random_thumb(path: &PathBuf) -> Option<PathBuf> {
        if !path.is_dir() || !path.exists() {
            return None;
        }

        let thumbs = read_dir(&path).ok()?.filter_map(|d| {
            let path = d.ok()?.path();
            if path.extension()? == *THUMB_FORMAT {
                return Some(path);
            }
            None
        });

        let mut rng = rand::thread_rng();
        Some(thumbs.choose(&mut rng)?)
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Dir {
    title: String,
    base_path: &'static str,
    read_only: bool,
    files: Vec<FileEntry>,
    folders: Vec<FileEntry>,
}

impl Dir {
    fn new() -> Self {
        Self {
            title: String::from(""),
            base_path: *BASEPATH,
            read_only: CFG.read_only,
            files: Vec::new(),
            folders: Vec::new(),
        }
    }
}

// Load DIR details into Dir struct
pub fn get_dir(dir: &PathBuf) -> Result<Dir, DirError> {
    if !dir.is_dir() {
        return Err(DirError::NotFound);
    }

    let mut page = Dir::new();
    let thpath = dir.join(".th");
    page.title = if let Ok(title) = dir.strip_prefix(&*DIR) {
        title.display().to_string()
    } else {
        dir.display().to_string()
    };

    for entry in read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();

        // Skip thumbnail dir
        if path == thpath {
            continue;
        }

        let details = FileEntry::from_entry(entry)?;

        // Folders display a random thumbnail from all their files (if available)
        // Files return their individual thumbnail (if available)
        if path.is_dir() {
            page.folders.push(details);
        } else {
            page.files.push(details);
        }
    }

    // Sort properly accounting for any number sequences
    page.files.sort_by(|a, b| {
        alphanumeric_sort::compare_str(a.name.to_lowercase(), b.name.to_lowercase())
    });
    page.folders.sort_by(|a, b| {
        alphanumeric_sort::compare_str(a.name.to_lowercase(), b.name.to_lowercase())
    });

    Ok(page)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_file_path_to_thumb() {
        let init = PathBuf::from("/dir/file.jpg");
        let result = Ok(PathBuf::from("/dir/.th/file.jpg.avif"));
        assert_eq!(
            FileEntry::file_path_to_thumb(&init),
            result,
            "Basic image path"
        );

        let init = PathBuf::from("/Pictures/Special Photos!/file@example.com/video.avi");
        let result = Ok(PathBuf::from(
            "/Pictures/Special Photos!/file@example.com/.th/video.avi.avif",
        ));
        assert_eq!(
            FileEntry::file_path_to_thumb(&init),
            result,
            "Uncommon video path"
        );

        let init = PathBuf::from("/home/user/Pictures/sub/../base.jpg");
        let result = Ok(PathBuf::from(
            "/home/user/Pictures/sub/../.th/base.jpg.avif",
        ));
        assert_eq!(
            FileEntry::file_path_to_thumb(&init),
            result,
            "Parent in path"
        );

        let init = PathBuf::from("/etc/config_file");
        let result = Ok(PathBuf::from("/etc/.th/config_file.avif"));
        assert_eq!(
            FileEntry::file_path_to_thumb(&init),
            result,
            "Path without file ext"
        );
    }

    #[test]
    fn test_get_random_thumb() {
        let dir = PathBuf::from(format!("{}imgs/.th", &*DIR.to_str().unwrap()));
        let thumb = FileEntry::get_random_thumb(&dir);
        assert!(thumb.is_some());
    }
}
